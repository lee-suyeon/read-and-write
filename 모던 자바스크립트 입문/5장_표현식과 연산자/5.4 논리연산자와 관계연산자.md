## 5.4 논리 연산자와 관계 연산자

---

<br />

### 5.4.1 관계연산자

- 두 개의 피연산자를 비교한 결과를 논리값(`true`/`false`)으로 반환한다.
- 주로 제어구조에서 **조건식**을 만들 때 사용. (if/else문, while문, do/while문, for문)

  ```jsx
  // 관계연산자

  a == b; // 값이 같음
  a != b; // 값이 다름
  a === b; // 값과 타입이 같음
  a !== b; // 값과 타입이 다름
  a < b; // 작음
  a > b; // 큼
  a <= b; // 작거나 같음
  a >= b; // 크거나 같음
  ```

<br />

`==` **동일 연산자**

- 좌변과 우변의 피연산자가 **같은지를 판별**
- 내부적으로는 좌우 피연산자의 타입을 변환한 다음에 좌변과 우변이 같은지를 느슨하게 비교
- 값이 같을 경우

  1. 좌우 피연산자의 타입이 같을 때

  - 값이 같으면 `true`, 다르면 `false`
  - 변수의 데이터 타입에 따라 달라진다 → 원시 타입, 객체 타입
  - 원시 타입 변수의 값은 **데이터 그 자체** / 객체 타입 변수의 값은 **객체의 참조**  
    → 객체 타입 변수의 값이 같은지를 판별하는 행위는 **같은 객체를 가리키는지**를 판별하는 것

    ```jsx
    // 변수 a와 b에는 모두 배열의 참조가 저장되어 있다.
    let a = [1, 2, 3];
    let b = [1, 2, 3];
    let c = a;

    console.log(a == b); // false
    // ➡️ 같은 데이터가 담겨 있지만 메모리에서 차지하는 위치가 다름

    console.log(a == c); // true
    ```

    <br />

  2. 좌우 피연산자의 타입이 다를 때

  - 두 피연산자가 **같은 타입이 되도록 변환**한 다음에 규칙에 따라 동일한지 판별

    - `undefined`와 `null`은 같은 것으로 친다.
    - 한쪽이 숫자고 다른 한쪽이 문자열이면 **문자열을 숫자로 변환**해서 비교한다.
    - 둘 중에 한쪽이 논리값이면 `true`는 **1**, `false`는 **0**으로 변환해서 비교한다.
    - 한쪽이 객체고 다른 한쪽이 숫자 또는 문자열이면 객체를 `toString`이나 `valueOf` 메서드를 사용해서 **원시 타입으로 변환**한 다음에 비교한다.
    - 앞의 규칙에서 벗어나면 모두 '**같지 않음**'으로 판정한다.

      ```jsx
      null == undefined; // true
      1 == "1"; // true
      "0xff" == 255; // true
      true == 1; // true
      (((true ==
        "1"(
          // true
          new String("a")
        )) ==
        "a"(
          // true
          new Number(2)
        )) ==
        (2)[2]) == // true
        2; // true
      ```

<br />

`===` **일치 연산자**

- 피연산자를 평가한 후에 **타입을 변환하지 않은 상태의 두 값을 엄격하게 비교**한다.
- 타입과 값이 모두 같으면 `true` 그렇지 않으면 `false`
- `NaN`을 포함한 모든 값과 같지 않다고 판정한다.
  ```jsx
  NaN === NaN; // false
  ```
- 동일 연산자에서는 `true`였던 표현식이 일치 연산자에서는 모두 `false`가 된다.

  ```jsx
  null === undefined; // false
  1 === "1"; // false
  "0xff" === 255; // false
  true === 1; // false
  (((true ===
    "1"(
      // false
      new String("a")
    )) ===
    "a"(
      // false
      new Number(2)
    )) ===
    (2)[2]) === // false
    2; // false
  ```

<br />

## 5.4.2 논리 연산자

관계 연산자를 사용하여 만든 논리식과 결합하여 더욱 복잡한 논리를 정의한다.

```jsx
// 논리곱 ➡️ a와 b가 모두 true면 true, 그 외에는 false
a && b;

// 논리합 ➡️ a와 b중 하나라도 true면 true, 모두가 false면 false
a || b;

// 부정 ➡️ a가 true면 false, false면 true
!a;
```

<br />

**피연산자의 평가**
논리연산을 할 때의 타입 변환

- `false` : 0, -0, 빈 문자열(""), NaN, null, undefined
- `true` : 0을 제외한 숫자, 빈 문자열을 제외한 문자열, 모든 객체, 심벌

<br />

**논리곱 연산자와 논리합 연산자의 단락 평가**

- 논리곱(`&&`) 연산자와 논리합(`||`) 연산자는 단락 평가(short-circuit evalution)를 한다.
- **단락평가**

  - 첫 번째 피연산자 값이 표현식을 결정하면 **두 번째 피연산자를 평가하지 않는 것**
  - 논리곱 연산자와 논리합 연산자는 논리값(`true`, `false`) 대신에 마지막으로 평가한
    **피연산자 값을 반환**

    ```jsx
    a && b;
    ```

    - a를 평가한 값이 `false`면 b의 값에 관계 없이 표현식 전체 값이 `false`  
       → b의 값 평가 ❌  
       → `false`를 반환하지 않고 a의 값 자체를 반환한다.
    - a를 평가한 값이 `true`면 전체 표현식 값이 **b**의 값으로 결정된다 → b의 값 자체를 반환
    - 객체의 프로퍼티를 이용할 때와 객체가 `null`인지 아닌지를 확인 하고자 할 때 유용

      ```jsx
      let p = null;

      p && p.name; // null ➡️ p가 false이므로 p를 반환, p.name 평가하지 않음

      p = { name: "Tom", age: 18 };
      p && p.name; // "Tom" ➡️ p가 true이므로 p.name을 반환

      // ➡️ p값이 null일 때 오류를 발생시키지 않는 방법
      ```

      <br />

      ```jsx
      a || b;
      ```

    - a를 평가한 값이 true면 b의 값에 관계 없이 표현식 전체 값이 `true`  
      → b의 값 평가 ❌  
      → `true` 를 반환하지 않고 a의 값 자체를 반환한다.
    - a를 평가한 값이 `false`면 전체 표현식 값이 **b**의 값으로 결정된다 → b의 값 자체를 반환
    - 여러 개의 값 후보 중에서 `null` 또는 `undefined`가 아닌 값을 선택하고자 할 때 유용하게 사용

      ```jsx
      let time = time_interval || animationSettings.time || 33;
      ```

      - `time_interval`이 정의되어 있을 때는 `time_interval`값을 사용
      - `time_interval`이 정의되지 않으면 `animationSettings`객체의 `time `프로퍼티를 사용
      - `animationSettings.time`이 정의되지 않았을 때는 정수 `33`을 사용

        <br />

    - 인수의 **초기값**을 설정할 때 유용하게 사용

      ```jsx
      function f(x) {
        x = x || 100;
      }

      f(); // x ➡️ undefined
      x = x || 100; // 100

      f(2); // x ➡️ 2
      x = x || 100; // 2

      // x에 false로 평가되는 값을 넘겼을 때
      f(0); // x ➡️ 0
      x = x || 100; // 100
      ```
