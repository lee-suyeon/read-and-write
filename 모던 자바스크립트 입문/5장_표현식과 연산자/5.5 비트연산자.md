## 5.5 비트 연산

---

데이터 통신이나 이진 파일을 처리할 때 자주 사용한다.

<br />

### 5.5.1 비트 연산

- **2진수** 숫자의 자리별 값(비트 값)을 다루는 연산
- 피연산자를 **부호 있는 32비트 정수**로 변환해서 처리한다.
- 부호 있는 8비트 정수로 변환되었을 때 첫 번째 비트는 **부호비트**이다.

  - 0 : 0 이상
  - 1 : 음수

  ```jsx
  a = 105 = 01101001(2);
  b = -91 = 10100101(2);
  ```

<br />

### 5.5.2 비트 논리 연산자

- 비트 값이 0이면 `false`, 1이면 `true`로 평가한다.

  ```jsx
  // 비트 논리곱(AND)
  105 & -91; // 33 = 00100001

  // 비트 논리합(OR)
  105 | -91; // -19 = 1101101

  // 비트 배타적 논리합(XOR) -> 두 숫자가 같으면 0을 반환 다르면 1을 반환
  105 ^ -91; // -52 = 11001100

  // 비트 논리 부정(NOT)
  ~105; // -106 = 10010110
  ```

<br />

### 5.5.3 비트 시프트 연산자

- 정수를 2진수 비트 단위로 오른쪽 또는 왼쪽으로 **이동**시키는 연산자
- 좌변의 비트 값을 우변에 지정된 수만큼 이동한다.

  - 빈자리는 0으로 채워지고 오버플로한 값은 버려진다.
  - 부호 있는 오른쪽 시프트 경우 → 빈자리는 피연산자가 원래 가지고 있던 부호 비트로 채워진다.

  ```jsx
  // 왼쪽 시프트 : 좌변의 비트 값을 우변에 지정된 수만큼 왼쪽으로 이동
  ((105 <<
    (3 - // 840(32)
      // 부호 있는 오른쪽 시프트
      91)) >>
    (3 - // -12(32)
      // 부호 없는 오른쪽 시프트
      91)) >>>
    3; // 536870900(32)
  ```

<br />

### 5.5.4 비트 연산의 대입 연산자

- 비트 연산에 대입 연산자를 사용할 수 있다.

  ```jsx
  a &= b; // a = a & b
  a |= b; // a = a | b
  a ^= b; // a = a ^ b
  a << n; // a = a << b
  a >> n; // a = a >> b
  a >>> n; // a = a >>> b
  ```
